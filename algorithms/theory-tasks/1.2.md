# Теоретическое задание 1.2

## Задача 1. Вдвое больший справа

### Обозначения
- $A$ - массив вещественных чисел длины $n$ - исходный массив
- $F$ - вспомогательный массив пар $(A_{i}, \space i)$ длины не больше, чем $n$
- $A_{i}$ - $i$-й элемент массива $A$, нумерация с 0
- $F_{last}$ - последний элемент массива $F$
### Решение
0. **Концепция**
    - Нужно держать в $F$ часть $A$ правее $A_{i}$, отфильтрованную по возрастанию (как после Stalin Sort :D), и тогда мы сможем запустить бинарный поиск значения $A_{i} \times 2$
        - ...но только вот придется хранить перевернутую версию этой части $A$... так еще и в парах с индексами
1. Итерация по индексу массива $i$ с конца (от $n - 1$ до $0$)
    - Тело цикла:
        - пока первый элемент $F_{last}$ меньше $A_{i}$, убрать $F_{last}$ (они теперь точно бесполезны, ведь $A_{i}$ левее и больше)
        - запустить бинарный поиск $A_{i} \times 2$ по первым элементам пар из $F$ (время: $O(\log n)$)
            - особенности реализации:
                - если искомое число больше, чем первый элемент $F_{0}$ (или $F$ пуст, как в первой итерации), вернуть `None`
                - когда указатели будут стоять рядом, вернуть левую границу (большее из двух)
                - вернуть индекс, то есть второй элемент найденной пары
            - можно куда-нибудь записать результат, чтобы потом вывести в нужном формате, все равно асимптотика по памяти будет $O(n)$
        - добавить пару $(A_{i}, \space i)$ в конец $F$
    - **Асимптотика**
        - время: каждая итерация $O(\log n)$, поэтому весь цикл - $O(n \log n)$
        - память: $O(n)$

## Задача 2. Прямая сумма и ее статистика

### Обозначения
- $A$ - первый массив
- $B$ - второй массив
- $|A|$ - размер массива $A$
- $A_{n}$ - $n$-й элемент массива $A$, нумерация с 0
- $i$ - переменная внутри цикла, считающая итерации, начиная с 0

### Решение
1. Создать (пустое) AVL-дерево (было на лекции: память - $O(k)$, время любой операции - $O(\log k)$ ($k$, потому что далее будет ровно $k$ итераций, в каждой из которых размер дерева не увеличивается более, чем на 1) (асимптотики доказывались на лекции))
    - ключи - (упорядоченные) тройки целых чисел (сравниваются сначала первые элементы, затем вторые, в конце - третьи)
2. Цикл из $k - 1$ итераций
    - Тело цикла:
        - если $i < A$:
            - добавить в дерево тройку: $(A_{i} + B_{0}, \space i, \space 0)$
        - найти и удалить из дерева наименьшую тройку (спускаться влево до вершины без левого ребенка)
            - обозначим ее $(sum, \space p, \space q)$
        - если $q < |B| - 1$:
            - добавить в дерево тройку: $(A_{p} + B_{q + 1}, \space p, \space q + 1)$
    - **Асимптотика**
        - время: в каждой итерации фиксированное количество операций с асимптотикой $O(\log k)$, поэтому асимптотика всего цикла - $O(k \log k)$
        - память: в каждой итерации размер дерева увеличивается не более, чем на 1, поэтому $O(k)$
3. Найти наименьшую тройку в дереве и вывести первый ее элемент

### Обоснование
- Решение строится на двух простейших утверждениях:
    - $A_{i} + B_{j} \leq A_{i} + B_{j + 1}$
        - позволяет хранить не более $|A|$ сумм в дереве (с индексами элементов, при сложении которых эта сумма получается, для добавления следующей суммы)
    - $A_{k} + B_{0} \leq (A \oplus B)_{k}$
        - гарантирует, что $i$-й порядковой статистикой не может оказаться элемент, в сумме которого участвует $A_{j}: \space j > i$
            - позволяет использовать именно $O(k)$ дополнительных ячеек памяти


## Задача 5. Непересекающиеся

### Обозначения
- `result` - глобальная целочисленная переменная, хранит в себе количество искомых пар и выводится после каждого запроса на добавление
    - только увеличивается, ведь пары не могут исчезнуть при добавлении отрезков
- $S_{S_{1}}$ - AVL-дерево для координат **начал** отрезков из $S_1$
- $E_{S_{1}}$ - AVL-дерево для координат **концов** отрезков из $S_1$
- $S_{S_{2}}$ - AVL-дерево для координат **начал** отрезков из $S_2$
- $E_{S_{2}}$ - AVL-дерево для координат **концов** отрезков из $S_2$

### Кастомные методы AVL-дерева
- `countLess(int delimiter)` - выводит количество вершин дерева с ключами меньше заданного значения
    - обозначим результат выполнения метода: `counter` (начальное значение - 0)
    - рекурсивный спуск по дереву с корня, пока `node != null`:
        - если `node.key == delimiter`
            - `counter += node.L.size`
            - выход из цикла
        - если `node.key > delimiter`
            - `counter += node.L.size + 1` (+1, потому что нужно посчитать и текущую вершину)
            - спуск вправо
        - иначе
            - спуск влево
    - возврат `counter`
    - **асимптотика** - $O(\log |S_{i}|)$ (всего один спуск по дереву, как в методе `find`)
- `countMore(int delimiter)` - выводит количество вершин дерева с ключами больше заданного значения
    - работает зеркально, асимптотика такая же

### Решение
1. Инициализация четырех (пустых) деревьев и `result` (начальное значение - 0)
2. Запросы добавления
    - Добавление в $S_{1}$:
        - пусть $s$ и $e$ - координаты начала и конца добавленного отрезка $L$ соответственно
        - добавляем $s$ в $S_{S_{1}}$, $e$ в $E_{S_{1}}$
            - **асимптотика** - $O(\log |S_{1}|)$
        - $left$ - результат вызова метода `countLess` с аргументом $s$ у дерева $E_{S_{2}}$
            - это количество концов отрезков из $S_{2}$, находящихся левее начала $L$ - то есть отрезков $S_{2}$, полностью находящихся левее $L$
            - **асимптотика** - $O(\log |S_{2}|)$
        - $right$ - результат вызова метода `countMore` с аргументом $e$ у дерева $S_{S_{2}}$
            - это количество начал отрезков из $S_{2}$, находящихся правее конца $L$ - то есть отрезков $S_{2}$, полностью находящихся правее $L$
            - **асимптотика** - $O(\log |S_{2}|)$
        - тогда количество отрезков из $S_{2}$, с которыми пересекается $L$ есть $|S_{2}| - left - right$
            - увеличиваем `result` на эту величину (и выводим)
        - **общая асимптотика** - $O(\log |S_{1}| + \log |S_{2}|)$
    - Добавление в $S_{2}$
        - работает зеркально, асимптотика такая же
