# Теоретическое задание 1.1

## Задача 1. Зацикленный

**Метод "черепахи и кролика"**
1. Запускаем два указателя по списку, где за каждую итерацию первый ("черепаха") переходит на 1 элемент вперед, а второй ("кролик") — на 2 элемента вперед.
    - Если "кролик" достигает узла с `nullptr`, то <u>цикла нет</u>
    - В противном случае, указатели рано или поздно встретятся (проверка этого достигается их сравнением) (ведь при наличии цикла "кролик" в какой-то момент "догонит" "черепаху", когда она войдет в цикл)
    - **Асимптотика** — $O(n)$
        - *в первом случае* — очевидно (итерации завершаются, когда "кролик" дойдет до конца списка)
        - *во втором случае*: "черепаха" сделает не более чем $n$ переходов, ведь как только она попадает в цикл, "кролик" ее догонит не более чем через $c - 1$ итераций, где $c$ — длина цикла. Таким образом, "черепаха" никогда не успеет дойти в начальный узел цикла до того, как "кролик" ее догонит, а значит, побывает в каждом элементе списка не более одного раза (исключение — список, являющийся одним большим циклом: тогда указатели встретятся на первом элементе списка).
    - Далее двигаемся только в случае, когда в списке есть цикл (когда указатели встретились)
2. **Сразу проверяем крайний случай**: если узел встречи указателей совпадает с первый узлом списка, то весь список — один большой цикл, и первый узел является начальным узлом цикла  
   Иначе пусть $s$ — количество узлов строго до цикла, $c$ — количество узлов в цикле, а $k$ — количество переходов, сделанное "черепахой" внутри цикла до встречи с "кроликом" (то есть, если проиндексировать узлы цикла, где начальный узел будет иметь индекс 0, то указатели встретятся в узле с индексом $k$), при этом $k < c$
    - В таком случае, после $s + k$ итераций "черепаха" сделала $s + k$ переходов, а "кролик" — $2(s + k)$, при этом разница количества их переходов $s + k$ кратна количеству узлов в цикле $c$  
      **Имеем:** $(s + k) \mathrel{\vdots} c$
    - В таком случае, если от начала списка выполнить ровно $2s + k$ переходов, то указатель окажется на начальном узле цикла (ведь $s + k$ переходов "схлопнется" в проход целого количества циклов)
    - Тогда, раз у нас оба указателя на элементе с индексом $s + k$ в *глобальной* индексации (где первый элемент всего списка имеет индекс 0), переместим один из них на первый элемент списка и запустим оба с шагом 1
    - Они встретятся ровно через $s$ итераций, потому что тот, что шел сначала, впервые попадет в начальный узел цикла, а тот, что шел от места встречи попадет в него же, согласно утверждению на два пункта выше
    - Таким образом находится <u>первый узел цикла</u>
    - **Асимптотика** — $O(n)$
        - *в крайнем случае* — $O(1)$
        - *иначе* — $O(s), s < n$
3. Ну и, наконец, нужно оставить один из указателей на месте (в начальном узле цикла), а второй запустить с шагом 1 с счетчиком итераций, и когда указатели вновь встретятся, на счетчике будет <u>длина цикла</u>
    - **Асимптотика** — $O(n)$, ведь $c \leq n$

## Задача 4. В поисках сдвига

### Пункт 1

**Функция "проверить, является индекс $i$ ответом задачи"**
- *Аргументы*
    - $i$ - целое число
    - входной массив
- *Логика*
    - сравнить $i$-й элемент массива с $(i-1)$-м (если $i = 0$, то с последний элементов массива)
    - вернуть `true`, если $i$-й элемент меньше, `false` иначе

**Что-то типа бинарного поиска**
- Буду называть окном часть массива с индексами на отрезке $[l, r]$
- Изначально $l = 0, \enspace r = n - 1$
- Посчитать середину отрезка $m = \frac{l + r}{2}$
- Запустить функцию "проверить, является индекс $i$ ответом задачи" от $m$ и $m + 1$, и если какой-то из вызовов возвращает `true`, вывести соответствующий индекс и закончить выполнение алгоритма
- Сравнить `array[l]` и `array[m]`
    - если `array[l] > array[m]`, то сделать присвоение `r = m - 1`
    - иначе сделать присвоение `l = m + 1`
- Перейти на следующую итерацию бинарного поиска
    - Рано или поздно функция вернет `true`, ведь при циклическом сдвиге отсортированного массива будет "излом" значений, и, собственно, мы его и ищем
- **Асимптотика** — $O(\log n)$
    - Каждую итерацию производится константное количество операций, при этом окно каждый раз сужается вдвое

### Пункт 2

В таком случае вполне может быть подан на вход массив, где все элементы, кроме последнего (или первого), будут одинаковы. И в таком случае задача сводится к поиску индекса отличающегося элемента среди остальных одинаковых. И человечество еще не придумало алгоритм для такой задачи, работающий быстрее, чем за линию.
