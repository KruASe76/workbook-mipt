# Деревья поиска

### Свойство узла
$\forall l \in L \enspace \forall r \in R \enspace l \leq x < r$

## Дерево поиска (бинарное)
(Бинарное) дерево, для которого выполнено **свойство узла**

### Операции

#### `find` $O(h)$
```java
boolean <E> find(Node node, E x) {
    if (node == null) {
        return false;
    }

    if (x == node.value) {
        return true;
    }

    if (x > node.value) {
        return find(node.right, x);
    }
    return find(node.left, x);
}
```

#### `insert` $O(h)$
Аналогично `find`, только если упираемся в `null`, вставляем новый узел

#### `remove` $O(h)$
1. `find(x)` $\to$ `node`
    - У `node` нет детей $\to$ удаляем `node`
    - У `node` 1 ребенок $\to$ указатель на `node` перебрасываем на ребенка
    - У `node` 2 ребенка
        1. идем 1 раз вправо
        2. ...а затем до упора влево
        3. в итоге находим некий элемент `w`, который будет наименьшим из элементов, больших `x`
        4. `swap(x, w)`, и теперь для выполнения **свойства узла** нужно удалить `x`
        5. но поскольку у `x` нет левого поддерева, можно применить случай, когда у `node` 0 или 1 ребенок

## AVL-дерево
Бинарное дерево поиска, в котором $\forall$ `node` $|h(nodeL) -  h(nodeR)| \leq 1$, где $h(T)$ - высота дерева

### Повороты
`diff(a)`$= h(aL) - h(aR)$

#### Малый левый (`diff(b) in {0, -1}`)
```
    a            b
   / \          / \
  /   b    ->  a   \
 /   / \      / \   \
A   B   C    A   B   C
```

#### Большой левый (`diff(a) == -2 && diff(b) == 1`)
*По сути два малых*
```
      a                  a                  c
     / \                / \                / \
    /   b              /   c              /   \
   /   / \     ->     /   / \     ->     /     \
  /   с   \          /   /   b          a       b        
 /   / \   \        /   /   / \        / \     / \       
A   B   C   D      A   B   C   D      A   B   C   D
```

### Операции

#### `fixUp(node)` $O(h)$
*Если `nodeL` и `nodeR` - корректные AVL-деревья*

1. В зависимости от дисбаланса выполни один из малых/больших левых/правых поворотов
2. `fixUp(node.parent)`

#### `insert` $O(h)$
1. Как в наивном дереве $\to$ `newNode`
2. `fixUp(newNode)`

#### `remove` $O(h)$
1. Как в наивном дереве
2. `fixUp(самый_нижний_затронутый_узел)`

### Утверждение
$h = O(\log N)$

- Пусть $S(h)$ - минимальное количество элементов в дереве высоты $h$
- $S(1) = 1, \enspace S(2) = 2, \enspace S(3) = 4$
- $S(h) = S(h-1) + S(h-2) + 1$
    - Лемма: $S(h) = Fib_{h+1} - 1$
        - *Индукция по $h$*

## Декартово дерево (Treap)
Дерево поиска, в узлах которого `(x, y)`, где `x` - ключ, `y` - приоритет
- по ключам - это дерево поиска
- по приоритетам - это бинарная куча

### Операции
#### `merge(T1, T2)` (`T1.keys() < T2.keys(), T1.root.y <= T2.root.y`) $O(h_{1} + h_{2})$
1. ставим корнем элемент с меньшим приоритетом
2. три поддерева:
    - совсем справа `T1.L`
    - совсем слева `T2.R`
    - по центру `merge(T1.R, T2.L)`

#### `split(T, x)`
- если `x > T.root.x`
    1. `T1, T2 = split(T.R, x)`
    2. `return merge(T.L, T1), T2`
- если `x < T.root.x`
    1. `T1, T2 = split(T.L, x)`
    2. `return T1, merge(T2, T.R)`

#### `insert(T, x)`
1. `T1, T2 = split(T, x)`
2. `T1' = merge(T1, new T(x))`
3. `return merge(T1', T2)`

#### `remove(T, x)`
- заменяем поддерево с корнем `x` на `merge()` его детей-поддеревьев

#### Теорема
Если выбирать приоритеты независимо и равновероятно из множества $\set{0, 1, \textellipsis, n - 1}$, где $n > |T|$, тогда мат. ожидание $E(h) = (\log |T|)$

## Splay-дерево
$C(x)$ - число вершин в поддереве, включая `x`  
$r(x) = \log_{2} C(x)$ ($r'(x)$ - после поворота)  
$\varphi(T) = \sum\limits_{x \in T} r(x)$

### Операции
#### `splay(T, x)`
поднять `x` в корень

1. `zig`
    - время работы $T \leq 1 + 3(r(t) - r(x))$
2. `zig-zig`
    - время работы $T \leq 3(r'(x) - r(x))$
3. `zig-zag`
    - время работы $T \leq 3(r'(x) - r(x))$

время работы $T_{splay} \leq 1 + 3(r(t) - r(x_{1})) + 3(r(x_{1}) - r(x_{2})) + 3(r(x_{2}) - r(x_{3})) + \textellipsis + 3(r(x_{k} - r(x_{0}))) = 1 + 3(r(t) - r(x_{0})) \leq 1 + 3 r(t) = 1 + 3 \log_{2} N = O(\log_{2} N)$

#### `merge(T1, T2)`
1. `splay(T1, max(T1))`
2. `T1.R = T2`

#### `find(T, x)`
1. как в обычном дереве
2. `splay(T, x)`

#### `split(T, x)`
1. `find(T, x)`
2. `return T.L, T.R`

#### `insert(T, x)`
1. как в обычном дереве
2. `splay(x)`

#### `remove(T, x)`
1. `Find(x)`
2. `merge(T.L, T.R)`
