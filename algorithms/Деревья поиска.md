# Деревья поиска

### Свойство узла
$\forall l \in L \enspace \forall r \in R \enspace l \leq x < r$

## Дерево поиска (бинарное)
(Бинарное) дерево, для которого выполнено **свойство узла**

### Операции

#### `find` $O(h)$
```java
boolean <E> find(Node node, E x) {
    if (node == null) {
        return false;
    }

    if (x == node.value) {
        return true;
    }

    if (x > node.value) {
        return find(node.right, x);
    }
    return find(node.left, x);
}
```

#### `insert` $O(h)$
Аналогично `find`, только если упираемся в `null`, вставляем новый узел

#### `remove` $O(h)$
1. `find(x)` $\to$ `node`
    - У `node` нет детей $\to$ удаляем `node`
    - У `node` 1 ребенок $\to$ указатель на `node` перебрасываем на ребенка
    - У `node` 2 ребенка
        1. идем 1 раз вправо
        2. ...а затем до упора влево
        3. в итоге находим некий элемент `w`, который будет наименьшим из элементов, больших `x`
        4. `swap(x, w)`, и теперь для выполнения **свойства узла** нужно удалить `x`
        5. но поскольку у `x` нет левого поддерева, можно применить случай, когда у `node` 0 или 1 ребенок

## AVL-дерево
Бинарное дерево поиска, в котором $\forall$ `node` $|h(nodeL) -  h(nodeR)| \leq 1$, где $h(T)$ - высота дерева

### Повороты
`diff(a)`$= h(aL) - h(aR)$

#### Малый левый (`diff(b) in {0, -1}`)
```
    a            b
   / \          / \
  /   b    ->  a   \
 /   / \      / \   \
A   B   C    A   B   C
```

#### Большой левый (`diff(a) == -2 && diff(b) == 1`)
*По сути два малых*
```
      a                  a                  c
     / \                / \                / \
    /   b              /   c              /   \
   /   / \     ->     /   / \     ->     /     \
  /   с   \          /   /   b          a       b        
 /   / \   \        /   /   / \        / \     / \       
A   B   C   D      A   B   C   D      A   B   C   D
```

### Операции

#### `fixUp(node)` $O(h)$
*Если `nodeL` и `nodeR` - корректные AVL-деревья*

1. В зависимости от дисбаланса выполни один из малых/больших левых/правых поворотов
2. `fixUp(node.parent)`

#### `insert` $O(2h)$
1. Как в наивном дереве $\to$ `newNode`
2. `fixUp(newNode)`

#### `remove` $O(2h)$
1. Как в наивном дереве
2. `fixUp(самый_нижний_затронутый_узел)`

### Утверждение
$h = O(\log N)$

- Пусть $S(h)$ - минимальное количество элементов в дереве высоты $h$
- $S(1) = 1, \enspace S(2) = 2, \enspace S(3) = 4$
- $S(h) = S(h-1) + S(h-2) + 1$
    - Лемма: $S(h) = Fib_{h+1} - 1$
        - *Индукция по $h$*
