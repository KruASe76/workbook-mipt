# Сортировки

## Radix sort

### Бинарная
![](radix_sort.excalidraw.svg)

### Пошире
Можно сделать больше очередей, например, сравнивать последний байт числа и 256 очередей

```java
public static final int queueCount = 256;
public static final int integerByteCount = 4;
public static final int byteBitCount = 8;
public static final int fullByte = 0xff;

public static void radixSort(int[] array) {
    List<Queue<Integer>> queues = new ArrayList<>();
    for (int i = 0; i < queueCount; i++) {
        queues.add(new LinkedList<>());
    }

    for (int byteIndex = 0; byteIndex < integerByteCount; byteIndex++) {
        for (int element : array) {
            int neededByte = (element >> (byteBitCount * byteIndex)) & fullByte;
            queues.get(neededByte).add(element);
        }

        int globalIndex = 0;
        for (Queue<Integer> queue : queues) {
            while (!queue.isEmpty()) {
                array[globalIndex] = queue.remove();
                globalIndex++;
            }
        }
    }

    int newStartIndex = 0;
    while (array[newStartIndex] >= 0) {
        newStartIndex++;
    }

    cyclicShift(array, array.length - newStartIndex);
}

public static void cyclicShift(int[] array, int amount) {
    reverseArrayPart(array, 0, array.length - amount - 1);
    reverseArrayPart(array, array.length - amount, array.length - 1);
    reverseArrayPart(array, 0, array.length - 1);
}

public static void reverseArrayPart(int[] array, int startIndex, int endIndex) {
    for (int i = startIndex, j = endIndex; i < j; i++, j--) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
```
