# Линейные контейнеры

## Свойства и операции

`(size, capacity)`

`push`
1. `size < capacity`: добавление за $O(1)$  
   `(size, capacity)` $\rightarrow$ `(size + 1, capacity)`
2. `size = capacity`: реаллокация за $O($`size`$)$  
   `(size, capacity)` $\rightarrow$ `(size + 1, capacity')`
## Амортизированное время
Пусть $t_{i}$ - реальное время $i$-й операции, тогда $t^{*} = \frac{1}{n} \sum\limits_{i=1}^{n} t_i$ - **амортизированное время**  
(но это оценка сверху, упрощенная)

### Метод бух. учета

При `push_1` $i$-го элемента
1. добавляем элемент
2. "кладем монетку" на $i$-й элемент
3. "кладем монетку" на $i - \frac{n}{2}$ элемент  
и эти монетки "тратятся" при `push_2`, то есть мы математически "размазываем" сложность `push_2` по `push_1`  
в итоге сложность **все равно линейная**
### Метод потенциалов
Пусть $S$ - наша структура, $S_{i}$ - состояние после $i$-го запроса, $S_{0}$ - начальное  
Тогда $\varphi$ - потенциал, если:
- $\varphi(S_{0})= 0$
- $\forall i \enspace \varphi(S_{i}) \geq 0$

- Обозначим
    - $t_{\varphi} = t_{i} + \varphi(S_{i}) - \varphi(S_{i-1})$
    - $t_{\varphi}^{*} = \frac{1}{n} \sum\limits_{i=1}^{n} t_{\varphi,i}$
- Утверждение
    - $t_{\varphi}^{*} \geq t^{*}$
        - $t_{\varphi}^{*} = \frac{1}{n} \sum\limits_{i=1}^{n} t_{\varphi,i} = \frac{1}{n} \left(\sum\limits_{i=1}^{n} t_{i} + \sum\limits_{i=1}^{n} (\varphi(S_{i}) - \varphi(S_{i-1}))\right) = \frac{1}{n} \sum\limits_{i=1}^{n} t_{i} + \frac{\varphi(S_{n}) - \varphi(S_{0})}{n} = t^{*} + \frac{\varphi(S_{n})}{n} \geq t^{*}$

короче после гениальных расчетов "накоплений энергии" получается, что в среднем все за $O(1)$

## Список
Это последовательный набор узлов
- **односвязный (`forward_list`)** -  `(value, *next)` - *никогда не использовать*
- **двусвязный (`linked_list`, `java.util.ArrayList`)** - `(value, *next, *previous)`

#### Стек
*LIFO - last in first out*

#### Очередь
*FIFO - first in first out*

#### Дек
*deque - double-ended queue*

#### Ring buffer
`arr[i] = (start + i) % size`

#### Очередь на двух стеках
- добавление в стек `in`
- удаление из стека `out`
    - если он пустой, итеративно перекладываем из `in` в `out` (и в процессе порядок переворачивается)
        - *методом монеток* объясняется, что `pop` работает за $O^{*}(1)$
